SQWOZ BAB КУПЕР





/* #include "freertos/FreeRTOS.h"

#include "freertos/task.h"

#include "freertos/queue.h"

  

TaskHandle_t Hello = NULL; // Дескриптор (хэндл) задачи

TaskHandle_t Hello1 = NULL; // Дескриптор (хэндл) задачи

  

static QueueHandle_t int_queue = NULL;

  

// Функция‑задача Hello_Task

void Hello_Task(void *arg){

    int r;

    while(1){

    for (int i = 0; i <= 100; i = i + 2)

    {

        xQueueSend(int_queue, &i, pdMS_TO_TICKS(0));

           // printf("otprav: %d\n", i);

        vTaskDelay(pdMS_TO_TICKS(30));

        xQueueReceive(int_queue, &r, pdMS_TO_TICKS(0));

    }

}

}

  

void Hello_Task1(void *arg){

    int prin;

    while(1){

        xQueueReceive(int_queue, &prin, portMAX_DELAY);

        printf("polychen: %d\n", prin);

        vTaskDelay(pdMS_TO_TICKS(70));

  

    }

}

 void print_task(void *arg)

{

  

}

void app_main(void) {

    // Создание задачи

    int_queue = xQueueCreate(2, sizeof(int));  // 10 элементов по 4 байта

    xTaskCreate(Hello_Task, "Hello0", 1024, NULL, 10, &Hello);

    xTaskCreate(Hello_Task1, "Hello1", 2048, NULL, 20, &Hello1);

} */

  
  

#include "freertos/FreeRTOS.h"

#include "freertos/task.h"

#include "freertos/semphr.h"

#include "driver/spi_master.h"

#include "driver/gpio.h"

#include "esp_log.h"

  

#define PIN_NUM_MISO  GPIO_NUM_NC  // Правильно: использовать GPIO_NUM_NC

#define PIN_NUM_MOSI  45

#define PIN_NUM_CLK   14

#define PIN_NUM_CS    3

#define PIN_NUM_DC    2

#define PIN_NUM_RST   46

  

static const char *TAG = "TFT_RTOSESP";

  

static spi_device_handle_t tft_spi;

static SemaphoreHandle_t tft_mutex;

  

// Безопасная отправка команды с проверкой mutex

static void tft_send_cmd(uint8_t cmd)

{

    if (xSemaphoreTake(tft_mutex, portMAX_DELAY) != pdTRUE) {

        return;

    }

    gpio_set_level(PIN_NUM_DC, 0);

    spi_transaction_t t = {

        .length = 8,

        .tx_buffer = &cmd

    };

    spi_device_transmit(tft_spi, &t);

    xSemaphoreGive(tft_mutex);

}

  

// Улучшенная функция отправки с объединением данных

static void tft_send_cmd_with_data(uint8_t cmd, const uint8_t *data, int len)

{

    if (xSemaphoreTake(tft_mutex, portMAX_DELAY) != pdTRUE) {

        return;

    }

    // Отправляем команду

    gpio_set_level(PIN_NUM_DC, 0);

    spi_transaction_t t_cmd = {

        .length = 8,

        .tx_buffer = &cmd

    };

    spi_device_transmit(tft_spi, &t_cmd);

    // Отправляем данные

    if (len > 0) {

        gpio_set_level(PIN_NUM_DC, 1);

        spi_transaction_t t_data = {

            .length = len * 8,

            .tx_buffer = data

        };

        spi_device_transmit(tft_spi, &t_data);

    }

    xSemaphoreGive(tft_mutex);

}

  

// Оптимизированная инициализация

static void tft_init_panel(void)

{

    // Объединяем данные для каждой команды

    tft_send_cmd_with_data(0x01, (uint8_t[]){0x00}, 1);

    vTaskDelay(pdMS_TO_TICKS(150));

    // Команда 0xCB с 5 байтами данных

    tft_send_cmd_with_data(0xCB, (uint8_t[]){0x39, 0x2C, 0x00, 0x34, 0x02}, 5);

    // Команда 0xCF с 3 байтами данных

    tft_send_cmd_with_data(0xCF, (uint8_t[]){0x00, 0xC1, 0x30}, 3);

    // Команда 0xE8 с 3 байтами данных

    tft_send_cmd_with_data(0xE8, (uint8_t[]){0x85, 0x00, 0x78}, 3);

    // Команда 0xEA с 2 байтами данных

    tft_send_cmd_with_data(0xEA, (uint8_t[]){0x00, 0x00}, 2);

    // Команда 0xED с 4 байтами данных

    tft_send_cmd_with_data(0xED, (uint8_t[]){0x64, 0x03, 0x12, 0x81}, 4);

    // Команда 0xF7 с 1 байтом данных

    tft_send_cmd_with_data(0xF7, (uint8_t[]){0x20}, 1);

    // Команда 0xC0 с 1 байтом данных

    tft_send_cmd_with_data(0xC0, (uint8_t[]){0x23}, 1);

    // Команда 0xC1 с 1 байтом данных

    tft_send_cmd_with_data(0xC1, (uint8_t[]){0x10}, 1);

    // Команда 0xC5 с 2 байтами данных

    tft_send_cmd_with_data(0xC5, (uint8_t[]){0x3E, 0x28}, 2);

    // Команда 0xC7 с 1 байтом данных

    tft_send_cmd_with_data(0xC7, (uint8_t[]){0x86}, 1);

    // Команда 0x36 с 1 байтом данных (ориентация)

    tft_send_cmd_with_data(0x36, (uint8_t[]){0x48}, 1);

    // Команда 0x3A с 1 байтом данных (цветовой формат - 0x55 = 16 бит)

    tft_send_cmd_with_data(0x3A, (uint8_t[]){0x55}, 1);

    // Команда 0xB1 с 2 байтами данных

    tft_send_cmd_with_data(0xB1, (uint8_t[]){0x00, 0x18}, 2);

    // Команда 0xB6 с 3 байтами данных

    tft_send_cmd_with_data(0xB6, (uint8_t[]){0x08, 0x82, 0x27}, 3);

    // Команда 0xF2 с 1 байтом данных

    tft_send_cmd_with_data(0xF2, (uint8_t[]){0x00}, 1);

    // Команда 0x26 с 1 байтом данных

    tft_send_cmd_with_data(0x26, (uint8_t[]){0x01}, 1);

    // Гамма-кривые (по 15 байт каждая)

    tft_send_cmd_with_data(0xE0, (uint8_t[]){0x0F, 0x31, 0x2B, 0x0C, 0x0E,

                                             0x08, 0x4E, 0xF1, 0x37, 0x07,

                                             0x10, 0x03, 0x0E, 0x09, 0x00}, 15);

    tft_send_cmd_with_data(0xE1, (uint8_t[]){0x00, 0x0E, 0x14, 0x03, 0x11,

                                             0x07, 0x31, 0xC1, 0x48, 0x08,

                                             0x0F, 0x0C, 0x31, 0x36, 0x0F}, 15);

    // Выход из сна

    tft_send_cmd_with_data(0x11, NULL, 0);

    vTaskDelay(pdMS_TO_TICKS(120));

    // Включение дисплея

    tft_send_cmd_with_data(0x29, NULL, 0);

}

  

/* static void tft_draw_pixel(uint16_t x, uint16_t y, uint16_t color)

{

    // 1. Устанавливаем область колонок (X координаты)

    // Отправляем команду 0x2A и 4 байта данных: x_start (2 байта) и x_end (2 байта)

    // Так как нам нужен только один пиксель, x_start = x, x_end = x

    uint8_t col_data[4] = {

        (x >> 8) & 0xFF, // Старший байт начальной X координаты

        x & 0xFF,        // Младший байт начальной X координаты

        (x >> 8) & 0xFF, // Старший байт конечной X координаты (та же)

        x & 0xFF         // Младший байт конечной X координаты (та же)

    };

    tft_send_cmd_with_data(0x2A, col_data, 4);

  

    // 2. Устанавливаем область строк (Y координаты)

    // Отправляем команду 0x2B и 4 байта данных: y_start (2 байта) и y_end (2 байта)

    uint8_t row_data[4] = {

        (y >> 8) & 0xFF, // Старший байт начальной Y координаты

        y & 0xFF,        // Младший байт начальной Y координаты

        (y >> 8) & 0xFF, // Старший байт конечной Y координаты (та же)

        y & 0xFF         // Младший байт конечной Y координаты (та же)

    };

    tft_send_cmd_with_data(0x2B, row_data, 4);

  

    // 3. Записываем цвет пикселя в память

    // Команда 0x2C переводит дисплей в режим записи данных

    tft_send_cmd(0x2C);

    // Отправляем цвет пикселя (2 байта для RGB565)

    uint8_t color_data[2] = {

        (color >> 8) & 0xFF, // Старший байт цвета

        color & 0xFF         // Младший байт цвета

    };

    tft_send_data(color_data, 2);

} */

  

// Пример заполнения экрана цветом

  
  
  

static void tft_fill_pixel(int x, int y, uint8_t color1, uint8_t color2)

{

        // 1. Устанавливаем область на весь экран

        uint8_t col_data[] = {

        (x >> 8) & 0xFF,  // Старший байт X

        x & 0xFF,         // Младший байт X

        (x >> 8) & 0xFF,  // Старший байт X (конец)

        x & 0xFF          // Младший байт X (конец)

    };

        uint8_t row_data[] = {

        (y >> 8) & 0xFF,  // Старший байт X

        y & 0xFF,         // Младший байт X

        (y >> 8) & 0xFF,  // Старший байт X (конец)

        y & 0xFF          // Младший байт X (конец)

    };

  uint8_t color_data[] = {color1, color2};

  

    tft_send_cmd_with_data(0x2A, col_data, 4);

    tft_send_cmd_with_data(0x2B, row_data, 4);

    tft_send_cmd(0x2C);

    if (xSemaphoreTake(tft_mutex, portMAX_DELAY) == pdTRUE) {

    gpio_set_level(PIN_NUM_DC, 1);

    spi_transaction_t t = {

        .length = 16,

        .tx_buffer = color_data

    };

    spi_device_transmit(tft_spi, &t);

     xSemaphoreGive(tft_mutex);

    }

  

    //ESP_LOGI(TAG, "Screen filled with black: %d bytes sent", bytes_to_send);

}

  
  
  
  

static void tft_fill_screen(void)

{

        // 1. Устанавливаем область на весь экран

    uint8_t col_data[] = {0x00, 0x00, 0x00, 0xEF}; // X: 0-319

    uint8_t row_data[] = {0x00, 0x00, 0x01, 0x3F}; // Y: 0-239

    tft_send_cmd_with_data(0x2A, col_data, 4);

    tft_send_cmd_with_data(0x2B, row_data, 4);

    tft_send_cmd(0x2C); // Memory write

    // 2. Создаем буфер с черным цветом

    #define BUF_SIZE 1024 // Отправляем по 1 КБ за раз

    // Важно: использовать DMA-совместимую память!

    uint8_t *buf = heap_caps_malloc(BUF_SIZE, MALLOC_CAP_DMA);

    if (!buf) {

        ESP_LOGE(TAG, "Failed to allocate buffer");

        return;

    }

    // Заполняем буфер нулями (черный цвет)

    //uint8_t color_data[] = {0xFF, 0xFF};

  

    memset(buf, 0, BUF_SIZE);

    // 3. Отправляем буфер много раз

    int bytes_to_send = 240 * 320 * 2; // Всего байт для отправки

    int remaining = bytes_to_send;

    while (remaining > 0) {

        int send_size = (remaining > BUF_SIZE) ? BUF_SIZE : remaining;

        // Отправляем кусок буфера

        if (xSemaphoreTake(tft_mutex, portMAX_DELAY) == pdTRUE) {

            gpio_set_level(PIN_NUM_DC, 1); // Режим данных

            spi_transaction_t t = {

                .length = send_size * 8,  // В битах

                .tx_buffer = buf

            };

            spi_device_transmit(tft_spi, &t);

            xSemaphoreGive(tft_mutex);

        }

        remaining -= send_size;

    }

    free(buf);

    //ESP_LOGI(TAG, "Screen filled with black: %d bytes sent", bytes_to_send);

}

  

static void tft_task(void *arg)

{

    tft_fill_screen();

    while (1) {

        for (int k = 0; k < 320  ; k = k + 1)

        {

            for (int x = 0; x < 240  ; x = x + 1 + k)

            {

                for (int y = 0; y <320  ; y = y  + x + k + 1)

                {

                    tft_fill_pixel(x, y, 0xFF, 0xFF);

                    vTaskDelay(pdMS_TO_TICKS(7));

                    //printf("%d, %d\n", x, y);

                }

            }

        }

        vTaskDelay(pdMS_TO_TICKS(500));

  

        for (int k = 0; k < 320  ; k = k + 1)

        {

            for (int x = 0; x < 240  ; x = x + 1 + k)

            {

                for (int y = 0; y <320  ; y = y  + x + k + 1)

                {

                    tft_fill_pixel(x, y, 0x00, 0x00);

                    vTaskDelay(pdMS_TO_TICKS(7));

                    //printf("%d, %d\n", x, y);

                }

            }

            vTaskDelay(pdMS_TO_TICKS(70));

        }

  

    }

}

  

void app_main(void)

{

    // Настройка GPIO для DC и RST

    gpio_config_t io_conf = {

        .pin_bit_mask = (1ULL << PIN_NUM_DC) | (1ULL << PIN_NUM_RST) | (1ULL << PIN_NUM_CS),

        .mode = GPIO_MODE_OUTPUT,

        .pull_up_en = GPIO_PULLUP_DISABLE,

        .pull_down_en = GPIO_PULLDOWN_DISABLE,

        .intr_type = GPIO_INTR_DISABLE

    };

    gpio_config(&io_conf);

    // CS по умолчанию неактивен (высокий уровень)

    gpio_set_level(PIN_NUM_CS, 1);

  

    // Аппаратный сброс

    gpio_set_level(PIN_NUM_RST, 0);

    vTaskDelay(pdMS_TO_TICKS(50));

    gpio_set_level(PIN_NUM_RST, 1);

    vTaskDelay(pdMS_TO_TICKS(50));

  

    // SPI шина

    spi_bus_config_t buscfg = {

        .miso_io_num = PIN_NUM_MISO,

        .mosi_io_num = PIN_NUM_MOSI,

        .sclk_io_num = PIN_NUM_CLK,

        .quadwp_io_num = -1,

        .quadhd_io_num = -1,

        .max_transfer_sz = 4096 // Увеличили для эффективности

    };

  

    esp_err_t ret = spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);

    if (ret != ESP_OK) {

        ESP_LOGE(TAG, "spi_bus_initialize failed: %d", ret);

        return;

    }

  

    spi_device_interface_config_t devcfg = {

        .clock_speed_hz = 26 * 1000 * 1000, // 26 МГц (более стабильно)

        .mode = 0,

        .spics_io_num = PIN_NUM_CS,

        .queue_size = 7,

        .flags = SPI_DEVICE_HALFDUPLEX

    };

  

    ret = spi_bus_add_device(SPI2_HOST, &devcfg, &tft_spi);

    if (ret != ESP_OK) {

        ESP_LOGE(TAG, "spi_bus_add_device failed: %d", ret);

        return;

    }

  

    tft_mutex = xSemaphoreCreateMutex();

    if (!tft_mutex) {

        ESP_LOGE(TAG, "Failed to create mutex");

        return;

    }

  

    // Инициализация дисплея

    tft_init_panel();

  

    // Создание задачи

    xTaskCreate(

        tft_task,

        "tft_task",

        16384 * 2, // Увеличили стек для работы с буферами

        NULL,

        5,

        NULL

    );

}



[env:freenove_esp32_s3_wroom]

platform = espressif32

board = freenove_esp32_s3_wroom

framework = espidf

monitor_speed = 115200


